/* automatically generated by rust-bindgen 0.68.1 */

pub const SVBCAMERA_ID_MAX: u32 = 128;
pub const SVB_BAYER_PATTERN_SVB_BAYER_RG: SVB_BAYER_PATTERN = 0;
pub const SVB_BAYER_PATTERN_SVB_BAYER_BG: SVB_BAYER_PATTERN = 1;
pub const SVB_BAYER_PATTERN_SVB_BAYER_GR: SVB_BAYER_PATTERN = 2;
pub const SVB_BAYER_PATTERN_SVB_BAYER_GB: SVB_BAYER_PATTERN = 3;
pub type SVB_BAYER_PATTERN = ::std::os::raw::c_uint;
pub const SVB_IMG_TYPE_SVB_IMG_RAW8: SVB_IMG_TYPE = 0;
pub const SVB_IMG_TYPE_SVB_IMG_RAW10: SVB_IMG_TYPE = 1;
pub const SVB_IMG_TYPE_SVB_IMG_RAW12: SVB_IMG_TYPE = 2;
pub const SVB_IMG_TYPE_SVB_IMG_RAW14: SVB_IMG_TYPE = 3;
pub const SVB_IMG_TYPE_SVB_IMG_RAW16: SVB_IMG_TYPE = 4;
pub const SVB_IMG_TYPE_SVB_IMG_Y8: SVB_IMG_TYPE = 5;
pub const SVB_IMG_TYPE_SVB_IMG_Y10: SVB_IMG_TYPE = 6;
pub const SVB_IMG_TYPE_SVB_IMG_Y12: SVB_IMG_TYPE = 7;
pub const SVB_IMG_TYPE_SVB_IMG_Y14: SVB_IMG_TYPE = 8;
pub const SVB_IMG_TYPE_SVB_IMG_Y16: SVB_IMG_TYPE = 9;
pub const SVB_IMG_TYPE_SVB_IMG_RGB24: SVB_IMG_TYPE = 10;
pub const SVB_IMG_TYPE_SVB_IMG_RGB32: SVB_IMG_TYPE = 11;
pub const SVB_IMG_TYPE_SVB_IMG_END: SVB_IMG_TYPE = -1;
pub type SVB_IMG_TYPE = ::std::os::raw::c_int;
pub const SVB_GUIDE_DIRECTION_SVB_GUIDE_NORTH: SVB_GUIDE_DIRECTION = 0;
pub const SVB_GUIDE_DIRECTION_SVB_GUIDE_SOUTH: SVB_GUIDE_DIRECTION = 1;
pub const SVB_GUIDE_DIRECTION_SVB_GUIDE_EAST: SVB_GUIDE_DIRECTION = 2;
pub const SVB_GUIDE_DIRECTION_SVB_GUIDE_WEST: SVB_GUIDE_DIRECTION = 3;
pub type SVB_GUIDE_DIRECTION = ::std::os::raw::c_uint;
pub const SVB_FLIP_STATUS_SVB_FLIP_NONE: SVB_FLIP_STATUS = 0;
pub const SVB_FLIP_STATUS_SVB_FLIP_HORIZ: SVB_FLIP_STATUS = 1;
pub const SVB_FLIP_STATUS_SVB_FLIP_VERT: SVB_FLIP_STATUS = 2;
pub const SVB_FLIP_STATUS_SVB_FLIP_BOTH: SVB_FLIP_STATUS = 3;
pub type SVB_FLIP_STATUS = ::std::os::raw::c_uint;
pub const SVB_CAMERA_MODE_SVB_MODE_NORMAL: SVB_CAMERA_MODE = 0;
pub const SVB_CAMERA_MODE_SVB_MODE_TRIG_SOFT: SVB_CAMERA_MODE = 1;
pub const SVB_CAMERA_MODE_SVB_MODE_TRIG_RISE_EDGE: SVB_CAMERA_MODE = 2;
pub const SVB_CAMERA_MODE_SVB_MODE_TRIG_FALL_EDGE: SVB_CAMERA_MODE = 3;
pub const SVB_CAMERA_MODE_SVB_MODE_TRIG_DOUBLE_EDGE: SVB_CAMERA_MODE = 4;
pub const SVB_CAMERA_MODE_SVB_MODE_TRIG_HIGH_LEVEL: SVB_CAMERA_MODE = 5;
pub const SVB_CAMERA_MODE_SVB_MODE_TRIG_LOW_LEVEL: SVB_CAMERA_MODE = 6;
pub const SVB_CAMERA_MODE_SVB_MODE_END: SVB_CAMERA_MODE = -1;
pub type SVB_CAMERA_MODE = ::std::os::raw::c_int;
pub const SVB_TRIG_OUTPUT_SVB_TRIG_OUTPUT_PINA: SVB_TRIG_OUTPUT = 0;
pub const SVB_TRIG_OUTPUT_SVB_TRIG_OUTPUT_PINB: SVB_TRIG_OUTPUT = 1;
pub const SVB_TRIG_OUTPUT_SVB_TRIG_OUTPUT_NONE: SVB_TRIG_OUTPUT = -1;
pub type SVB_TRIG_OUTPUT = ::std::os::raw::c_int;
pub use self::SVB_TRIG_OUTPUT as SVB_TRIG_OUTPUT_PIN;
pub const SVB_ERROR_CODE_SVB_SUCCESS: SVB_ERROR_CODE = 0;
pub const SVB_ERROR_CODE_SVB_ERROR_INVALID_INDEX: SVB_ERROR_CODE = 1;
pub const SVB_ERROR_CODE_SVB_ERROR_INVALID_ID: SVB_ERROR_CODE = 2;
pub const SVB_ERROR_CODE_SVB_ERROR_INVALID_CONTROL_TYPE: SVB_ERROR_CODE = 3;
pub const SVB_ERROR_CODE_SVB_ERROR_CAMERA_CLOSED: SVB_ERROR_CODE = 4;
pub const SVB_ERROR_CODE_SVB_ERROR_CAMERA_REMOVED: SVB_ERROR_CODE = 5;
pub const SVB_ERROR_CODE_SVB_ERROR_INVALID_PATH: SVB_ERROR_CODE = 6;
pub const SVB_ERROR_CODE_SVB_ERROR_INVALID_FILEFORMAT: SVB_ERROR_CODE = 7;
pub const SVB_ERROR_CODE_SVB_ERROR_INVALID_SIZE: SVB_ERROR_CODE = 8;
pub const SVB_ERROR_CODE_SVB_ERROR_INVALID_IMGTYPE: SVB_ERROR_CODE = 9;
pub const SVB_ERROR_CODE_SVB_ERROR_OUTOF_BOUNDARY: SVB_ERROR_CODE = 10;
pub const SVB_ERROR_CODE_SVB_ERROR_TIMEOUT: SVB_ERROR_CODE = 11;
pub const SVB_ERROR_CODE_SVB_ERROR_INVALID_SEQUENCE: SVB_ERROR_CODE = 12;
pub const SVB_ERROR_CODE_SVB_ERROR_BUFFER_TOO_SMALL: SVB_ERROR_CODE = 13;
pub const SVB_ERROR_CODE_SVB_ERROR_VIDEO_MODE_ACTIVE: SVB_ERROR_CODE = 14;
pub const SVB_ERROR_CODE_SVB_ERROR_EXPOSURE_IN_PROGRESS: SVB_ERROR_CODE = 15;
pub const SVB_ERROR_CODE_SVB_ERROR_GENERAL_ERROR: SVB_ERROR_CODE = 16;
pub const SVB_ERROR_CODE_SVB_ERROR_INVALID_MODE: SVB_ERROR_CODE = 17;
pub const SVB_ERROR_CODE_SVB_ERROR_INVALID_DIRECTION: SVB_ERROR_CODE = 18;
pub const SVB_ERROR_CODE_SVB_ERROR_UNKNOW_SENSOR_TYPE: SVB_ERROR_CODE = 19;
pub const SVB_ERROR_CODE_SVB_ERROR_END: SVB_ERROR_CODE = 20;
pub type SVB_ERROR_CODE = ::std::os::raw::c_uint;
pub const SVB_BOOL_SVB_FALSE: SVB_BOOL = 0;
pub const SVB_BOOL_SVB_TRUE: SVB_BOOL = 1;
pub type SVB_BOOL = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SVB_CAMERA_INFO {
    pub FriendlyName: [::std::os::raw::c_char; 32usize],
    pub CameraSN: [::std::os::raw::c_char; 32usize],
    pub PortType: [::std::os::raw::c_char; 32usize],
    pub DeviceID: ::std::os::raw::c_uint,
    pub CameraID: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SVB_CAMERA_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<SVB_CAMERA_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SVB_CAMERA_INFO>(),
        104usize,
        concat!("Size of: ", stringify!(SVB_CAMERA_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<SVB_CAMERA_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(SVB_CAMERA_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FriendlyName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SVB_CAMERA_INFO),
            "::",
            stringify!(FriendlyName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CameraSN) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SVB_CAMERA_INFO),
            "::",
            stringify!(CameraSN)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PortType) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SVB_CAMERA_INFO),
            "::",
            stringify!(PortType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeviceID) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SVB_CAMERA_INFO),
            "::",
            stringify!(DeviceID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CameraID) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(SVB_CAMERA_INFO),
            "::",
            stringify!(CameraID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SVB_CAMERA_PROPERTY {
    pub MaxHeight: ::std::os::raw::c_long,
    pub MaxWidth: ::std::os::raw::c_long,
    pub IsColorCam: SVB_BOOL,
    pub BayerPattern: SVB_BAYER_PATTERN,
    pub SupportedBins: [::std::os::raw::c_int; 16usize],
    pub SupportedVideoFormat: [SVB_IMG_TYPE; 8usize],
    pub MaxBitDepth: ::std::os::raw::c_int,
    pub IsTriggerCam: SVB_BOOL,
}
#[test]
fn bindgen_test_layout_SVB_CAMERA_PROPERTY() {
    const UNINIT: ::std::mem::MaybeUninit<SVB_CAMERA_PROPERTY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SVB_CAMERA_PROPERTY>(),
        128usize,
        concat!("Size of: ", stringify!(SVB_CAMERA_PROPERTY))
    );
    assert_eq!(
        ::std::mem::align_of::<SVB_CAMERA_PROPERTY>(),
        8usize,
        concat!("Alignment of ", stringify!(SVB_CAMERA_PROPERTY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxHeight) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SVB_CAMERA_PROPERTY),
            "::",
            stringify!(MaxHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxWidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SVB_CAMERA_PROPERTY),
            "::",
            stringify!(MaxWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsColorCam) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SVB_CAMERA_PROPERTY),
            "::",
            stringify!(IsColorCam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BayerPattern) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SVB_CAMERA_PROPERTY),
            "::",
            stringify!(BayerPattern)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedBins) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SVB_CAMERA_PROPERTY),
            "::",
            stringify!(SupportedBins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedVideoFormat) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SVB_CAMERA_PROPERTY),
            "::",
            stringify!(SupportedVideoFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxBitDepth) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(SVB_CAMERA_PROPERTY),
            "::",
            stringify!(MaxBitDepth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsTriggerCam) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(SVB_CAMERA_PROPERTY),
            "::",
            stringify!(IsTriggerCam)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SVB_CAMERA_PROPERTY_EX {
    pub bSupportPulseGuide: SVB_BOOL,
    pub bSupportControlTemp: SVB_BOOL,
    pub Unused: [::std::os::raw::c_int; 64usize],
}
#[test]
fn bindgen_test_layout_SVB_CAMERA_PROPERTY_EX() {
    const UNINIT: ::std::mem::MaybeUninit<SVB_CAMERA_PROPERTY_EX> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SVB_CAMERA_PROPERTY_EX>(),
        264usize,
        concat!("Size of: ", stringify!(SVB_CAMERA_PROPERTY_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<SVB_CAMERA_PROPERTY_EX>(),
        4usize,
        concat!("Alignment of ", stringify!(SVB_CAMERA_PROPERTY_EX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bSupportPulseGuide) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SVB_CAMERA_PROPERTY_EX),
            "::",
            stringify!(bSupportPulseGuide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bSupportControlTemp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SVB_CAMERA_PROPERTY_EX),
            "::",
            stringify!(bSupportControlTemp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Unused) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SVB_CAMERA_PROPERTY_EX),
            "::",
            stringify!(Unused)
        )
    );
}
pub const SVB_CONTROL_TYPE_SVB_GAIN: SVB_CONTROL_TYPE = 0;
pub const SVB_CONTROL_TYPE_SVB_EXPOSURE: SVB_CONTROL_TYPE = 1;
pub const SVB_CONTROL_TYPE_SVB_GAMMA: SVB_CONTROL_TYPE = 2;
pub const SVB_CONTROL_TYPE_SVB_GAMMA_CONTRAST: SVB_CONTROL_TYPE = 3;
pub const SVB_CONTROL_TYPE_SVB_WB_R: SVB_CONTROL_TYPE = 4;
pub const SVB_CONTROL_TYPE_SVB_WB_G: SVB_CONTROL_TYPE = 5;
pub const SVB_CONTROL_TYPE_SVB_WB_B: SVB_CONTROL_TYPE = 6;
pub const SVB_CONTROL_TYPE_SVB_FLIP: SVB_CONTROL_TYPE = 7;
pub const SVB_CONTROL_TYPE_SVB_FRAME_SPEED_MODE: SVB_CONTROL_TYPE = 8;
pub const SVB_CONTROL_TYPE_SVB_CONTRAST: SVB_CONTROL_TYPE = 9;
pub const SVB_CONTROL_TYPE_SVB_SHARPNESS: SVB_CONTROL_TYPE = 10;
pub const SVB_CONTROL_TYPE_SVB_SATURATION: SVB_CONTROL_TYPE = 11;
pub const SVB_CONTROL_TYPE_SVB_AUTO_TARGET_BRIGHTNESS: SVB_CONTROL_TYPE = 12;
pub const SVB_CONTROL_TYPE_SVB_BLACK_LEVEL: SVB_CONTROL_TYPE = 13;
pub const SVB_CONTROL_TYPE_SVB_COOLER_ENABLE: SVB_CONTROL_TYPE = 14;
pub const SVB_CONTROL_TYPE_SVB_TARGET_TEMPERATURE: SVB_CONTROL_TYPE = 15;
pub const SVB_CONTROL_TYPE_SVB_CURRENT_TEMPERATURE: SVB_CONTROL_TYPE = 16;
pub const SVB_CONTROL_TYPE_SVB_COOLER_POWER: SVB_CONTROL_TYPE = 17;
pub const SVB_CONTROL_TYPE_SVB_BAD_PIXEL_CORRECTION_ENABLE: SVB_CONTROL_TYPE = 18;
pub type SVB_CONTROL_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SVB_CONTROL_CAPS {
    pub Name: [::std::os::raw::c_char; 64usize],
    pub Description: [::std::os::raw::c_char; 128usize],
    pub MaxValue: ::std::os::raw::c_long,
    pub MinValue: ::std::os::raw::c_long,
    pub DefaultValue: ::std::os::raw::c_long,
    pub IsAutoSupported: SVB_BOOL,
    pub IsWritable: SVB_BOOL,
    pub ControlType: SVB_CONTROL_TYPE,
    pub Unused: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout__SVB_CONTROL_CAPS() {
    const UNINIT: ::std::mem::MaybeUninit<_SVB_CONTROL_CAPS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SVB_CONTROL_CAPS>(),
        264usize,
        concat!("Size of: ", stringify!(_SVB_CONTROL_CAPS))
    );
    assert_eq!(
        ::std::mem::align_of::<_SVB_CONTROL_CAPS>(),
        8usize,
        concat!("Alignment of ", stringify!(_SVB_CONTROL_CAPS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SVB_CONTROL_CAPS),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Description) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SVB_CONTROL_CAPS),
            "::",
            stringify!(Description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxValue) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_SVB_CONTROL_CAPS),
            "::",
            stringify!(MaxValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinValue) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_SVB_CONTROL_CAPS),
            "::",
            stringify!(MinValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DefaultValue) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_SVB_CONTROL_CAPS),
            "::",
            stringify!(DefaultValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsAutoSupported) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_SVB_CONTROL_CAPS),
            "::",
            stringify!(IsAutoSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsWritable) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(_SVB_CONTROL_CAPS),
            "::",
            stringify!(IsWritable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ControlType) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_SVB_CONTROL_CAPS),
            "::",
            stringify!(ControlType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Unused) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(_SVB_CONTROL_CAPS),
            "::",
            stringify!(Unused)
        )
    );
}
pub type SVB_CONTROL_CAPS = _SVB_CONTROL_CAPS;
pub const SVB_EXPOSURE_STATUS_SVB_EXP_IDLE: SVB_EXPOSURE_STATUS = 0;
pub const SVB_EXPOSURE_STATUS_SVB_EXP_WORKING: SVB_EXPOSURE_STATUS = 1;
pub const SVB_EXPOSURE_STATUS_SVB_EXP_SUCCESS: SVB_EXPOSURE_STATUS = 2;
pub const SVB_EXPOSURE_STATUS_SVB_EXP_FAILED: SVB_EXPOSURE_STATUS = 3;
pub type SVB_EXPOSURE_STATUS = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SVB_ID {
    pub id: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout__SVB_ID() {
    const UNINIT: ::std::mem::MaybeUninit<_SVB_ID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SVB_ID>(),
        64usize,
        concat!("Size of: ", stringify!(_SVB_ID))
    );
    assert_eq!(
        ::std::mem::align_of::<_SVB_ID>(),
        1usize,
        concat!("Alignment of ", stringify!(_SVB_ID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SVB_ID),
            "::",
            stringify!(id)
        )
    );
}
pub type SVB_ID = _SVB_ID;
pub type SVB_SN = SVB_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SVB_SUPPORTED_MODE {
    pub SupportedCameraMode: [SVB_CAMERA_MODE; 16usize],
}
#[test]
fn bindgen_test_layout__SVB_SUPPORTED_MODE() {
    const UNINIT: ::std::mem::MaybeUninit<_SVB_SUPPORTED_MODE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SVB_SUPPORTED_MODE>(),
        64usize,
        concat!("Size of: ", stringify!(_SVB_SUPPORTED_MODE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SVB_SUPPORTED_MODE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SVB_SUPPORTED_MODE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedCameraMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SVB_SUPPORTED_MODE),
            "::",
            stringify!(SupportedCameraMode)
        )
    );
}
pub type SVB_SUPPORTED_MODE = _SVB_SUPPORTED_MODE;
extern "C" {
    #[doc = "Descriptions:\nthis should be the first API to be called\nget number of connected SVB cameras,\n\nParas:\n\nreturn:number of connected SVB cameras. 1 means 1 camera connected."]
    pub fn SVBGetNumOfConnectedCameras() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nget the information of the connected cameras, you can do this without open the camera.\nhere is the sample code:\n\nint iNumofConnectCameras = SVBGetNumOfConnectedCameras();\nSVB_CAMERA_INFO **ppSVBCameraInfo = (SVB_CAMERA_INFO **)malloc(sizeof(SVB_CAMERA_INFO *)*iNumofConnectCameras);\nfor(int i = 0; i < iNumofConnectCameras; i++)\n{\nppSVBCameraInfo[i] = (SVB_CAMERA_INFO *)malloc(sizeof(SVB_CAMERA_INFO ));\nSVBGetCameraInfo(ppSVBCameraInfo[i], i);\n}\n\nParas:\nSVB_CAMERA_INFO *pSVBCameraInfo: Pointer to structure containing the information of camera\nuser need to malloc the buffer\nint iCameraIndex: 0 means the first connect camera, 1 means the second connect camera\n\nreturn:\nSVB_SUCCESS: Operation is successful\nSVB_ERROR_INVALID_INDEX  :no camera connected or index value out of boundary"]
    pub fn SVBGetCameraInfo(
        pSVBCameraInfo: *mut SVB_CAMERA_INFO,
        iCameraIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nget the property of the connected cameras\nhere is the sample code:\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraProperty\nSVB_CAMERA_PROPERTY *pCameraProperty: Pointer to structure containing the property of camera\nuser need to malloc the buffer\n\nreturn:\nSVB_SUCCESS: Operation is successful\nSVB_ERROR_INVALID_INDEX  :no camera connected or index value out of boundary"]
    pub fn SVBGetCameraProperty(
        iCameraID: ::std::os::raw::c_int,
        pCameraProperty: *mut SVB_CAMERA_PROPERTY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nget the property of the connected cameras\nhere is the sample code:\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraProperty\nSVB_CAMERA_PROPERTY_EX *pCameraPorpertyEx: Pointer to structure containing the property of camera\nuser need to malloc the buffer\n\nreturn:\nSVB_SUCCESS: Operation is successful\nSVB_ERROR_INVALID_INDEX  :no camera connected or index value out of boundary"]
    pub fn SVBGetCameraPropertyEx(
        iCameraID: ::std::os::raw::c_int,
        pCameraPorpertyEx: *mut SVB_CAMERA_PROPERTY_EX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nopen the camera before any operation to the camera, this will not affect the camera which is capturing\nAll APIs below need to open the camera at first.\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\n\nreturn:\nSVB_SUCCESS: Operation is successful\nSVB_ERROR_INVALID_ID  : no camera of this ID is connected or ID value is out of boundary\nSVB_ERROR_CAMERA_REMOVED: failed to find the camera, maybe camera has been removed"]
    pub fn SVBOpenCamera(iCameraID: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nyou need to close the camera to free all the resource\n\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\n\nreturn:\nSVB_SUCCESS :it will return success even the camera already closed\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary"]
    pub fn SVBCloseCamera(iCameraID: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nGet number of controls available for this camera. the camera need be opened at first.\n\n\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\nint * piNumberOfControls: pointer to an int to save the number of controls\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary"]
    pub fn SVBGetNumOfControls(
        iCameraID: ::std::os::raw::c_int,
        piNumberOfControls: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nGet controls property available for this camera. the camera need be opened at first.\nuser need to malloc and maintain the buffer.\n\n\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\nint iControlIndex: index of control, NOT control type\nSVB_CONTROL_CAPS * pControlCaps: Pointer to structure containing the property of the control\nuser need to malloc the buffer\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary"]
    pub fn SVBGetControlCaps(
        iCameraID: ::std::os::raw::c_int,
        iControlIndex: ::std::os::raw::c_int,
        pControlCaps: *mut SVB_CONTROL_CAPS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nGet controls property value and auto value\nnote:the value of the temperature is the float value * 10 to convert it to long type, control name is \"Temperature\"\nbecause long is the only type for control(except cooler's target temperature, because it is an integer)\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\nint ControlType: this is get from control property use the API SVBGetControlCaps\nlong *plValue: pointer to the value you want to save the value get from control\nSVB_BOOL *pbAuto: pointer to the SVB_BOOL type\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary\nSVB_ERROR_INVALID_CONTROL_TYPE, //invalid Control type"]
    pub fn SVBGetControlValue(
        iCameraID: ::std::os::raw::c_int,
        ControlType: ::std::os::raw::c_int,
        plValue: *mut ::std::os::raw::c_long,
        pbAuto: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nSet controls property value and auto value\nit will return success and set the max value or min value if the value is beyond the boundary\n\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\nint ControlType: this is get from control property use the API SVBGetControlCaps\nlong lValue: the value set to the control\nSVB_BOOL bAuto: set the control auto\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary\nSVB_ERROR_INVALID_CONTROL_TYPE, //invalid Control type\nSVB_ERROR_GENERAL_ERROR,//general error, eg: value is out of valid range; operate to camera hareware failed"]
    pub fn SVBSetControlValue(
        iCameraID: ::std::os::raw::c_int,
        ControlType: ::std::os::raw::c_int,
        lValue: ::std::os::raw::c_long,
        bAuto: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nGet the output image type.\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\nSVB_IMG_TYPE *pImageType: pointer to current image type.\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary\nSVB_ERROR_GENERAL_ERROR,//general error, eg: value is out of valid range; operate to camera hareware failed"]
    pub fn SVBGetOutputImageType(
        iCameraID: ::std::os::raw::c_int,
        pImageType: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nSet the output image type, The value set must be the type supported by the SVBGetCameraProperty function.\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\nSVB_IMG_TYPE *pImageType: pointer to current image type.\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary\nSVB_ERROR_INVALID_IMGTYPE, //invalid image type\nSVB_ERROR_GENERAL_ERROR,//general error, eg: value is out of valid range; operate to camera hareware failed"]
    pub fn SVBSetOutputImageType(
        iCameraID: ::std::os::raw::c_int,
        ImageType: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nset the ROI area before capture.\nyou must stop capture before call it.\nthe width and height is the value after binning.\nie. you need to set width to 640 and height to 480 if you want to run at 640X480@BIN2\nSVB120's data size must be times of 1024 which means width*height%1024=0SVBSetStartPos\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\nint iWidth,  the width of the ROI area. Make sure iWidth%8 = 0.\nint iHeight,  the height of the ROI area. Make sure iHeight%2 = 0,\nfurther, for USB2.0 camera SVB120, please make sure that iWidth*iHeight%1024=0.\nint iBin,   binning method. bin1=1, bin2=2\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary\nSVB_ERROR_INVALID_SIZE, //wrong video format size\nSVB_ERROR_INVALID_IMGTYPE, //unsupported image format, make sure iWidth and iHeight and binning is set correct"]
    pub fn SVBSetROIFormat(
        iCameraID: ::std::os::raw::c_int,
        iStartX: ::std::os::raw::c_int,
        iStartY: ::std::os::raw::c_int,
        iWidth: ::std::os::raw::c_int,
        iHeight: ::std::os::raw::c_int,
        iBin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nGet the current ROI area setting .\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\nint *piWidth,  pointer to the width of the ROI area\nint *piHeight, pointer to the height of the ROI area.\nint *piBin,   pointer to binning method. bin1=1, bin2=2\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary"]
    pub fn SVBGetROIFormat(
        iCameraID: ::std::os::raw::c_int,
        piStartX: *mut ::std::os::raw::c_int,
        piStartY: *mut ::std::os::raw::c_int,
        piWidth: *mut ::std::os::raw::c_int,
        piHeight: *mut ::std::os::raw::c_int,
        piBin: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nGet the droped frames .\ndrop frames happen when USB is traffic or harddisk write speed is slow\nit will reset to 0 after stop capture\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\nint *piDropFrames pointer to drop frames\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary"]
    pub fn SVBGetDroppedFrames(
        iCameraID: ::std::os::raw::c_int,
        piDropFrames: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nStart video capture\nthen you can get the data from the API SVBGetVideoData\n\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\n\nreturn:\nSVB_SUCCESS : Operation is successful, it will return success if already started\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary\nSVB_ERROR_EXPOSURE_IN_PROGRESS: snap mode is working, you need to stop snap first"]
    pub fn SVBStartVideoCapture(iCameraID: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nStop video capture\n\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\n\nreturn:\nSVB_SUCCESS : Operation is successful, it will return success if already stopped\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary"]
    pub fn SVBStopVideoCapture(iCameraID: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nget data from the video buffer.the buffer is very small\nyou need to call this API as fast as possible, otherwise frame will be discarded\nso the best way is maintain one buffer loop and call this API in a loop\nplease make sure the buffer size is biger enough to hold one image\notherwise the this API will crash\n\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\nunsigned char* pBuffer, caller need to malloc the buffer, make sure the size is big enough\nthe size in byte:\n8bit mono:width*height\n16bit mono:width*height*2\nRGB24:width*height*3\n\nint iWaitms, this API will block and wait iWaitms to get one image. the unit is ms\n-1 means wait forever. this value is recommend set to exposure*2+500ms\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary\nSVB_ERROR_TIMEOUT: no image get and timeout"]
    pub fn SVBGetVideoData(
        iCameraID: ::std::os::raw::c_int,
        pBuffer: *mut ::std::os::raw::c_uchar,
        lBuffSize: ::std::os::raw::c_long,
        iWaitms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nWhite balance once time. If success(return SVB_SUCCESS), please get SVB_WB_R, SVB_WB_G and SVB_WB_B values to update UI display.\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary\nSVB_ERROR_GENERAL_ERROR : white balance failed"]
    pub fn SVBWhiteBalanceOnce(iCameraID: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nGets the camera firmware version number\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\nchar *pCameraFirmwareVersion: A Buffer to store the version number, which needs to be at least 64 bytes in size\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary"]
    pub fn SVBGetCameraFirmwareVersion(
        iCameraID: ::std::os::raw::c_int,
        pCameraFirmwareVersion: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nget version string, like \"1, 13, 0503\""]
    pub fn SVBGetSDKVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Description:\nGet the camera supported mode, only need to call when the IsTriggerCam in the CameraInfo is true.\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\nSVB_SUPPORTED_MODE: the camera supported mode\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary"]
    pub fn SVBGetCameraSupportMode(
        iCameraID: ::std::os::raw::c_int,
        pSupportedMode: *mut SVB_SUPPORTED_MODE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Description:\nGet the camera current mode, only need to call when the IsTriggerCam in the CameraInfo is true\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\nSVB_CAMERA_MODE *mode: the current camera mode\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary"]
    pub fn SVBGetCameraMode(
        iCameraID: ::std::os::raw::c_int,
        mode: *mut SVB_CAMERA_MODE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Description:\nSet the camera mode, only need to call when the IsTriggerCam in the CameraInfo is true\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\nSVB_CAMERA_MODE: this is get from the camera property use the API SVBGetCameraProperty\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_SEQUENCE : camera is in capture now, need to stop capture first.\nSVB_ERROR_INVALID_MODE  : mode is out of boundary or this camera do not support this mode"]
    pub fn SVBSetCameraMode(
        iCameraID: ::std::os::raw::c_int,
        mode: SVB_CAMERA_MODE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Description:\nSend out a softTrigger. For edge trigger, it only need to set true which means send a\nrising trigger to start exposure. For level trigger, it need to set true first means\nstart exposure, and set false means stop exposure.it only need to call when the\nIsTriggerCam in the CameraInfo is true\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open"]
    pub fn SVBSendSoftTrigger(iCameraID: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Description:\nGet a serial number from a camera.\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\nSVB_SN* pSN: pointer to SN\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_GENERAL_ERROR : camera does not have Serial Number"]
    pub fn SVBGetSerialNumber(
        iCameraID: ::std::os::raw::c_int,
        pSN: *mut SVB_SN,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Description:\nConfig the output pin (A or B) of Trigger port. If lDuration <= 0, this output pin will be closed.\nOnly need to call when the IsTriggerCam in the CameraInfo is true\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo.\nSVB_TRIG_OUTPUT_STATUS pin: Select the pin for output\nSVB_BOOL bPinAHigh: If true, the selected pin will output a high level as a signal\nwhen it is effective. Or it will output a low level as a signal.\nlong lDelay: the time between the camera receive a trigger signal and the output\nof the valid level.From 0 microsecond to 2000*1000*1000 microsecond.\nlong lDuration: the duration time of the valid level output.From 0 microsecond to\n2000*1000*1000 microsecond.\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_GENERAL_ERROR : the parameter is not right"]
    pub fn SVBSetTriggerOutputIOConf(
        iCameraID: ::std::os::raw::c_int,
        pin: SVB_TRIG_OUTPUT_PIN,
        bPinHigh: ::std::os::raw::c_int,
        lDelay: ::std::os::raw::c_long,
        lDuration: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Description:\nGet the output pin configuration, only need to call when the IsTriggerCam in the CameraInfo is true\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo.\nSVB_TRIG_OUTPUT_STATUS pin: Select the pin for getting the configuration\nSVB_BOOL *bPinAHigh: Get the current status of valid level.\nlong *lDelay: get the time between the camera receive a trigger signal and the output of the valid level.\nlong *lDuration: get the duration time of the valid level output.\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary\nSVB_ERROR_GENERAL_ERROR : the parameter is not right"]
    pub fn SVBGetTriggerOutputIOConf(
        iCameraID: ::std::os::raw::c_int,
        pin: SVB_TRIG_OUTPUT_PIN,
        bPinHigh: *mut ::std::os::raw::c_int,
        lDelay: *mut ::std::os::raw::c_long,
        lDuration: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Description:\nSend a PulseGuide command to camera to control the telescope\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo.\nSVB_GUIDE_DIRECTION direction: the direction\nint duration: the duration of pulse, unit is milliseconds\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary\nSVB_ERROR_GENERAL_ERROR : the parameter is not right\nSVB_ERROR_INVALID_DIRECTION : invalid guide direction"]
    pub fn SVBPulseGuide(
        iCameraID: ::std::os::raw::c_int,
        direction: ::std::os::raw::c_int,
        duration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Description:\nGet sensor pixel size in microns\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo.\nfloat *fPixelSize: sensor pixel size in microns\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary\nSVB_ERROR_UNKNOW_SENSOR_TYPE : unknow sensor type"]
    pub fn SVBGetSensorPixelSize(
        iCameraID: ::std::os::raw::c_int,
        fPixelSize: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Description:\nGet whether to support pulse guide\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo.\nSVB_BOOL *pIsSupportPulseGuide: if SVB_TRUE then support pulse guide\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary"]
    pub fn SVBCanPulseGuide(
        iCameraID: ::std::os::raw::c_int,
        pCanPulseGuide: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Description:\nWhether to save the parameter file automatically\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo.\nSVB_BOOL enable: if SVB_TRUE then save the parameter file automatically.\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary"]
    pub fn SVBSetAutoSaveParam(
        iCameraID: ::std::os::raw::c_int,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nDetect if the camera firmware needs to be upgraded\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\nSVB_BOOL *pIsNeedToUpgrade: Return to whether the camera needs to be upgraded\nchar *pNeedToUpgradeMinVersion: A Buffer to store the version number, which needs to be at least 64 bytes in size\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary"]
    pub fn SVBIsCameraNeedToUpgrade(
        iCameraID: ::std::os::raw::c_int,
        pIsNeedToUpgrade: *mut ::std::os::raw::c_int,
        pNeedToUpgradeMinVersion: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Descriptions:\nRestore default parameters\n\nParas:\nint CameraID: this is get from the camera property use the API SVBGetCameraInfo\n\nreturn:\nSVB_SUCCESS : Operation is successful\nSVB_ERROR_CAMERA_CLOSED : camera didn't open\nSVB_ERROR_INVALID_ID  :no camera of this ID is connected or ID value is out of boundary\nSVB_ERROR_GENERAL_ERROR : other error"]
    pub fn SVBRestoreDefaultParam(iCameraID: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
